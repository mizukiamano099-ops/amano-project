// src/emitters/zod/zod-emitter.js
//
// 強化版 Zod Emitter
// IR (Intermediate Representation) から TypeScript + Zod のスキーマ文字列を生成します。
// 対応事項：
//  - primitive types (string, number, boolean)
//  - formats: email, uuid, url, integer
//  - nullable (.nullable()), optional (.optional())
//  - default (.default(value))
//  - number constraints: minimum, maximum
//  - arrays: { type: "array", items: { ... } }
//  - nested objects (再帰処理)
//  - date/timestamp -> z.string().datetime() (or z.date() 注釈)
//  - entity 間の参照は z.lazy(() => OtherSchema) として循環参照に対応
//
// 使い方（例）:
//   const emitter = new ZodEmitter();
//   const code = emitter.emit(ir); // code は TypeScript ファイル内容（文字列）
//

class ZodEmitter {
  constructor(options = {}) {
    // options で出力スタイル等を制御可能（将来的な拡張）
    this.options = options;
  }

  /**
   * メインエントリポイント
   * @param {object} ir - 中間表現。 { definitions: { Name: { type: 'object', properties: {...} } } }
   * @returns {string} TypeScript のコード文字列
   */
  emit(ir) {
    // 定義済みエンティティ名リスト（参照/循環参照対応で利用）
    const entityNames = this._collectEntityNames(ir);

    // ヘッダコメント + import
    const parts = [];
    parts.push('// -------------------------------------------------');
    parts.push('// Auto-generated by Amano ZodEmitter');
    parts.push('// DO NOT EDIT MANUALLY');
    parts.push('// -------------------------------------------------');
    parts.push(`import { z } from "zod";`);
    parts.push('');

    // 先に forward 宣言を行う（循環参照を扱うために lazy で使えるように）
    // 実際には z.lazy(() => XSchema) を利用するので forward 宣言は型上の注意喚起コメントに留める
    // 実装側は各 Schema を export const XxxSchema = z.lazy(() => z.object({...}));
    // ここでは definitions の順にスキーマを出力する。
    for (const [name, def] of Object.entries(ir.definitions || {})) {
      parts.push(`// =============== ${name} Schema ===============`);
      // 本体
      const schemaBody = this._emitSchemaForDefinition(name, def, entityNames);
      parts.push(schemaBody);
      parts.push('');
      // TS型
      parts.push(`export type ${name} = z.infer<typeof ${name}Schema>;`);
      parts.push('');
    }

    return parts.join('\n');
  }

  /**
   * IR 定義からスキーマ本体を生成する。
   * 各エンティティは z.lazy(() => z.object({...})) 形式で出力する（循環参照安全）
   * @param {string} name
   * @param {object} def
   * @param {string[]} entityNames
   */
  _emitSchemaForDefinition(name, def, entityNames) {
    // def が object 以外の場合の簡易対応
    if (!def || def.type !== 'object' || !def.properties) {
      // スキーマが object でない場合は z.any() を返す
      return `export const ${name}Schema = z.any(); // Unsupported or empty definition`;
    }

    // プロパティ生成
    const lines = [];
    for (const [propName, propDef] of Object.entries(def.properties || {})) {
      const expr = this._emitZodExpressionForProperty(propDef, entityNames);
      lines.push(`  ${propName}: ${expr},${this._makeInlineComment(propDef)}`);
    }

    // 組み立て：lazy + object
    const body =
`export const ${name}Schema = z.lazy(() => z.object({
${lines.join('\n')}
}));`;

    return body;
  }

  /**
   * プロパティ定義（propDef）から Zod 式を生成する
   * 再帰的にオブジェクト/配列を処理する
   */
  _emitZodExpressionForProperty(propDef, entityNames) {
    // 標準化：もし propDef が primitive のみならラップ
    const d = Object.assign({}, propDef);

    // type が配列で表現される（例: "Post[]"）なら配列扱いへ変換しておく
    if (typeof d.type === 'string' && d.type.endsWith('[]') && !d.items) {
      const base = d.type.replace(/\[\]$/, '');
      d.type = 'array';
      d.items = { type: base };
    }

    // 配列
    if (d.type === 'array') {
      if (!d.items) {
        // 要素定義がない場合は any
        var elemExpr = 'z.any()';
      } else {
        var elemExpr = this._emitZodExpressionForProperty(d.items, entityNames);
      }
      let arrExpr = `z.array(${elemExpr})`;
      // nullable/optional/default 等の付与は後処理で
      return this._applyModifiers(arrExpr, d);
    }

    // オブジェクト（ネスト）
    if (d.type === 'object') {
      // ネスト内の properties を再帰的に処理
      const innerLines = [];
      const props = d.properties || {};
      for (const [k, v] of Object.entries(props)) {
        const ex = this._emitZodExpressionForProperty(v, entityNames);
        innerLines.push(`    ${k}: ${ex},${this._makeInlineComment(v)}`);
      }
      let objExpr = `z.object({\n${innerLines.join('\n')}\n  })`;
      return this._applyModifiers(objExpr, d);
    }

    // date / timestamp
    if (d.type === 'date' || d.type === 'timestamp') {
      // Zod の datetime() は string に対するチェック
      // ここでは z.string().datetime() を優先で出力（実運用で z.date() を使いたければ後段で変換）
      let base = `z.string().datetime()`;
      return this._applyModifiers(base, d);
    }

    // primitive or entity reference
    // まず、entityNames に含まれるならリレーション（参照）
    if (typeof d.type === 'string' && entityNames.includes(d.type)) {
      // 他エンティティ参照（単数）
      let base = `z.lazy(() => ${d.type}Schema)`;
      return this._applyModifiers(base, d);
    }

    // プリミティブマッピング
    let base = this._mapPrimitiveToZod(d);
    return this._applyModifiers(base, d);
  }

  /**
   * primitive のマッピング（format, min/max 等を内包）
   * @param {object} d
   */
  _mapPrimitiveToZod(d) {
    const t = d.type;
    // string 系
    if (t === 'string' || t === 'uuid' || t === 'email' || t === 'url') {
      let expr = 'z.string()';
      if (d.format === 'email' || t === 'email') expr += '.email()';
      if (d.format === 'uuid' || t === 'uuid') expr += '.uuid()';
      if (d.format === 'url') expr += '.url()';
      // integer 指定（string じゃなく number で integer が来るケースは below）
      return expr;
    }

    if (t === 'number' || t === 'integer' || t === 'Int' || t === 'Float') {
      // base number
      let expr = 'z.number()';
      // integer check: z.number().int()
      if (d.format === 'integer' || t === 'integer' || t === 'Int') {
        expr += '.int()';
      }
      // min/max
      if (typeof d.minimum === 'number') expr += `.min(${d.minimum})`;
      if (typeof d.maximum === 'number') expr += `.max(${d.maximum})`;
      return expr;
    }

    if (t === 'boolean' || t === 'bool') {
      return 'z.boolean()';
    }

    // fallback
    return 'z.any()';
  }

  /**
   * 与えられた z 表現 expr に対して nullable/optional/default を順に適用する
   * 優先度（適用順）: base -> .nullable() -> .optional() -> .default(...)
   *
   * 注意: Zod の .default() は optional を含むため、.default() を付ける場合は .optional() を
   * 省略しても構わないがここでは明示的に optional を付ける。
   */
  _applyModifiers(expr, def) {
    let out = expr;

    // nullable
    if (def.nullable) {
      out += `.nullable()`;
    }

    // optional / required
    // IR の required が false または explicit false なら optional
    if (def.required === false) {
      out += `.optional()`;
    } else {
      // required が true or undefined -> required (no .optional)
    }

    // default
    if (def.hasOwnProperty('default')) {
      // default が文字列なら JSON.stringify してそのまま埋める
      const jsDefault = JSON.stringify(def.default);
      // default は通常 optional に影響する： .default(...) は optional を内包するため
      out += `.default(${jsDefault})`;
    }

    return out;
  }

  /**
   * inline comment を生成する（isRelation, description, format, unique など）
   */
  _makeInlineComment(def) {
    const notes = [];
    if (def.description) notes.push(def.description);
    if (def.format) notes.push(`format:${def.format}`);
    if (def.isRelation) notes.push('relation');
    if (def.isUnique) notes.push('unique');
    // 合成
    if (notes.length === 0) return '';
    return ` // ${notes.join(' | ')}`;
  }

  /**
   * IR から entity 名の配列を取得（参照判定用）
   */
  _collectEntityNames(ir) {
    const defs = ir.definitions || {};
    return Object.keys(defs);
  }
}

module.exports = { ZodEmitter };
